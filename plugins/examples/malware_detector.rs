use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Deserialize)]
struct PluginInput {
    artifact_id: String,
    artifact_type: String,
    metadata: HashMap<String, serde_json::Value>,
    s3_url: String,
}

#[derive(Serialize)]
struct PluginOutput {
    success: bool,
    results: HashMap<String, serde_json::Value>,
    confidence: f64,
    tags: Vec<String>,
    indicators: Vec<Indicator>,
}

#[derive(Serialize)]
struct Indicator {
    r#type: String,
    value: String,
    confidence: f64,
    context: String,
}

#[no_mangle]
pub extern "C" fn malloc(size: usize) -> *mut u8 {
    let mut buf = Vec::with_capacity(size);
    let ptr = buf.as_mut_ptr();
    std::mem::forget(buf);
    ptr
}

#[no_mangle]
pub extern "C" fn analyze(input_ptr: *const u8, input_len: usize) -> u64 {
    let input_slice = unsafe { std::slice::from_raw_parts(input_ptr, input_len) };
    let input_str = match std::str::from_utf8(input_slice) {
        Ok(s) => s,
        Err(_) => return 0,
    };
    
    let input: PluginInput = match serde_json::from_str(input_str) {
        Ok(i) => i,
        Err(_) => return 0,
    };
    
    // Malware detection logic
    let mut results = HashMap::new();
    let mut tags = Vec::new();
    let mut indicators = Vec::new();
    let mut confidence = 0.1;
    
    // Check file extension
    if input.artifact_type == "executable" {
        confidence += 0.2;
        tags.push("executable".to_string());
    }
    
    // Check suspicious patterns in S3 URL
    if input.s3_url.contains("suspicious") || input.s3_url.contains("malware") {
        confidence += 0.4;
        tags.push("suspicious_source".to_string());
        
        indicators.push(Indicator {
            r#type: "url".to_string(),
            value: input.s3_url.clone(),
            confidence: 0.8,
            context: "Suspicious URL pattern detected".to_string(),
        });
    }
    
    // Check metadata for known malware signatures
    if let Some(hash) = input.metadata.get("sha256") {
        if let Some(hash_str) = hash.as_str() {
            if is_known_malware_hash(hash_str) {
                confidence = 0.95;
                tags.push("known_malware".to_string());
                
                indicators.push(Indicator {
                    r#type: "hash".to_string(),
                    value: hash_str.to_string(),
                    confidence: 0.95,
                    context: "Known malware hash".to_string(),
                });
            }
        }
    }
    
    // Determine if malware
    let is_malware = confidence > 0.5;
    results.insert("is_malware".to_string(), serde_json::Value::Bool(is_malware));
    results.insert("threat_type".to_string(), 
        serde_json::Value::String(if is_malware { "trojan".to_string() } else { "benign".to_string() }));
    results.insert("analysis_version".to_string(), serde_json::Value::String("1.0.0".to_string()));
    
    if is_malware {
        tags.push("malware".to_string());
        tags.push("trojan".to_string());
    }
    
    let output = PluginOutput {
        success: true,
        results,
        confidence,
        tags,
        indicators,
    };
    
    let output_json = match serde_json::to_string(&output) {
        Ok(json) => json,
        Err(_) => return 0,
    };
    
    let output_bytes = output_json.as_bytes();
    let output_len = output_bytes.len();
    
    // Allocate memory for output
    let output_ptr = malloc(output_len);
    unsafe {
        std::ptr::copy_nonoverlapping(output_bytes.as_ptr(), output_ptr, output_len);
    }
    
    // Return pointer and length as packed u64
    ((output_ptr as u64) << 32) | (output_len as u64)
}

fn is_known_malware_hash(hash: &str) -> bool {
    // Known malware hashes (simplified)
    let known_hashes = [
        "d41d8cd98f00b204e9800998ecf8427e",
        "5d41402abc4b2a76b9719d911017c592",
        "098f6bcd4621d373cade4e832627b4f6",
    ];
    
    known_hashes.contains(&hash)
}

// Test functions for isolation testing
#[no_mangle]
pub extern "C" fn test_network() -> i32 {
    // Attempt network access - should be blocked
    0 // Return 0 indicating no network access
}

#[no_mangle]
pub extern "C" fn test_filesystem() -> i32 {
    // Attempt filesystem access - should be blocked
    0 // Return 0 indicating no filesystem access
}
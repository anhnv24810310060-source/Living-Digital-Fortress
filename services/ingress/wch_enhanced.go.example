package main

import (
	"bytes"
	"context"
	crand "crypto/rand"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"
	"time"
	
	"shieldx/pkg/wch"
	"shieldx/pkg/ledger"
)

// Enhanced Whisper Channel Protocol (WCH) handlers with production optimizations
// Implements secure end-to-end encrypted tunneling for suspicious traffic

const (
	maxEnvelopeSize = 256 * 1024 // 256KB max sealed message size
	maxChannels     = 10000       // Max concurrent channels per instance
	channelTTL      = 15 * time.Minute
	cleanupInterval = 2 * time.Minute
)

// channelState represents an active WCH channel
type channelState struct {
	id              string
	guardianPubKey  []byte
	createdAt       time.Time
	lastActivity    time.Time
	requestCount    int64
	bytesRelayed    int64
	expiresAt       time.Time
	rekeyCounter    int
	
	// Rate limiting per channel
	rateLimit       int
	rateWindow      time.Duration
	rateBucket      tokenBucket
	
	mu              sync.RWMutex
}

type tokenBucket struct {
	tokens    int
	resetTime time.Time
}

// channelRegistry manages active WCH channels
type channelRegistry struct {
	channels map[string]*channelState
	mu       sync.RWMutex
	
	// Metrics
	activeChannels   *sync.Map // for O(1) count
	totalCreated     int64
	totalExpired     int64
	totalRelayed     int64
}

var (
	registry *channelRegistry
	once     sync.Once
)

// getRegistry returns the singleton channel registry
func getRegistry() *channelRegistry {
	once.Do(func() {
		registry = &channelRegistry{
			channels:       make(map[string]*channelState),
			activeChannels: &sync.Map{},
		}
		
		// Start background cleanup goroutine
		go registry.cleanupExpiredChannels()
	})
	return registry
}

// createChannel creates a new WCH channel with Guardian
func (reg *channelRegistry) createChannel(guardianPubKey []byte) (*channelState, error) {
	reg.mu.Lock()
	defer reg.mu.Unlock()
	
	// Check channel limit
	if len(reg.channels) >= maxChannels {
		return nil, fmt.Errorf("channel limit reached: %d", maxChannels)
	}
	
	// Generate unique channel ID (16 random bytes hex-encoded)
	channelID, err := generateChannelID()
	if err != nil {
		return nil, fmt.Errorf("failed to generate channel ID: %w", err)
	}
	
	now := time.Now()
	state := &channelState{
		id:             channelID,
		guardianPubKey: guardianPubKey,
		createdAt:      now,
		lastActivity:   now,
		expiresAt:      now.Add(channelTTL),
		rateLimit:      100, // 100 requests per minute per channel
		rateWindow:     time.Minute,
		rateBucket:     tokenBucket{tokens: 100, resetTime: now.Add(time.Minute)},
	}
	
	reg.channels[channelID] = state
	reg.activeChannels.Store(channelID, true)
	reg.totalCreated++
	
	return state, nil
}

// getChannel retrieves a channel by ID
func (reg *channelRegistry) getChannel(channelID string) (*channelState, bool) {
	reg.mu.RLock()
	defer reg.mu.RUnlock()
	
	ch, exists := reg.channels[channelID]
	if !exists {
		return nil, false
	}
	
	// Check if expired
	if time.Now().After(ch.expiresAt) {
		return nil, false
	}
	
	return ch, true
}

// removeChannel removes a channel from registry
func (reg *channelRegistry) removeChannel(channelID string) {
	reg.mu.Lock()
	defer reg.mu.Unlock()
	
	delete(reg.channels, channelID)
	reg.activeChannels.Delete(channelID)
}

// cleanupExpiredChannels periodically removes expired channels
func (reg *channelRegistry) cleanupExpiredChannels() {
	ticker := time.NewTicker(cleanupInterval)
	defer ticker.Stop()
	
	for range ticker.C {
		reg.mu.Lock()
		now := time.Now()
		expired := []string{}
		
		for id, ch := range reg.channels {
			if now.After(ch.expiresAt) {
				expired = append(expired, id)
			}
		}
		
		for _, id := range expired {
			delete(reg.channels, id)
			reg.activeChannels.Delete(id)
			reg.totalExpired++
		}
		
		reg.mu.Unlock()
		
		if len(expired) > 0 {
			// Log cleanup (would use structured logger in production)
			_ = ledger.AppendJSONLine(ledgerPath, serviceName, "wch.cleanup", map[string]any{
				"expired_count": len(expired),
				"active_count":  len(reg.channels),
			})
		}
	}
}

// getStats returns registry statistics
func (reg *channelRegistry) getStats() map[string]interface{} {
	reg.mu.RLock()
	defer reg.mu.RUnlock()
	
	activeCount := 0
	reg.activeChannels.Range(func(_, _ interface{}) bool {
		activeCount++
		return true
	})
	
	return map[string]interface{}{
		"active_channels": activeCount,
		"total_created":   reg.totalCreated,
		"total_expired":   reg.totalExpired,
		"total_relayed":   reg.totalRelayed,
	}
}

// handleWCHConnect handles WCH channel establishment
// POST /wch/connect with token validation
func handleWCHConnect(w http.ResponseWriter, r *http.Request) {
	mConnect.Inc()
	
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	
	// Parse request
	var req connectRequest
	if err := json.NewDecoder(io.LimitReader(r.Body, 4096)).Decode(&req); err != nil {
		http.Error(w, "invalid request", http.StatusBadRequest)
		return
	}
	
	if req.Token == "" {
		http.Error(w, "missing token", http.StatusBadRequest)
		return
	}
	
	// Validate token with locator service
	claims, err := validateTokenWithLocator(r.Context(), req.Token)
	if err != nil {
		mConnectDenied.Inc()
		_ = ledger.AppendJSONLine(ledgerPath, serviceName, "wch.connect.denied", map[string]any{
			"error":  err.Error(),
			"ip":     clientIP(r),
			"corrId": getCorrID(r),
		})
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	
	// Policy evaluation (check if WCH is allowed for this tenant)
	tenant := getClaimString(claims, "tenant")
	scope := getClaimString(claims, "scope")
	
	if !policyAllowWCH(tenant, scope) {
		mConnectDenied.Inc()
		http.Error(w, "forbidden", http.StatusForbidden)
		return
	}
	
	// Request Guardian public key
	guardianPubKey, err := requestGuardianPubKey(r.Context())
	if err != nil {
		http.Error(w, "service unavailable", http.StatusServiceUnavailable)
		return
	}
	
	// Create channel
	reg := getRegistry()
	channel, err := reg.createChannel(guardianPubKey)
	if err != nil {
		http.Error(w, "channel creation failed", http.StatusInternalServerError)
		return
	}
	
	// Build response
	resp := wch.ConnectResponse{
		ChannelID:      channel.id,
		GuardianPubB64: base64EncodeBytes(guardianPubKey),
		Protocol:       wch.Protocol,
		ExpiresAt:      channel.expiresAt.Unix(),
		RebindHintMs:   int(channelTTL.Milliseconds() - 60000), // Suggest rebind 1min before expiry
	}
	
	// Log success
	_ = ledger.AppendJSONLine(ledgerPath, serviceName, "wch.connect.success", map[string]any{
		"channelId": channel.id,
		"tenant":    tenant,
		"scope":     scope,
		"expiresAt": channel.expiresAt.Unix(),
		"corrId":    getCorrID(r),
	})
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

// handleWCHSend handles sealed message relay to Guardian
// POST /wch/send with encrypted envelope
func handleWCHSend(w http.ResponseWriter, r *http.Request) {
	mSend.Inc()
	
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	
	// Parse envelope
	var envelope wch.Envelope
	body := io.LimitReader(r.Body, maxEnvelopeSize)
	if err := json.NewDecoder(body).Decode(&envelope); err != nil {
		mSendRejected.Inc()
		http.Error(w, "invalid envelope", http.StatusBadRequest)
		return
	}
	
	// Validate envelope fields
	if envelope.ChannelID == "" || envelope.EphemeralPubB64 == "" || 
	   envelope.NonceB64 == "" || envelope.CiphertextB64 == "" {
		mSendRejected.Inc()
		http.Error(w, "incomplete envelope", http.StatusBadRequest)
		return
	}
	
	// Lookup channel
	reg := getRegistry()
	channel, exists := reg.getChannel(envelope.ChannelID)
	if !exists {
		mSendRejected.Inc()
		http.Error(w, "channel not found or expired", http.StatusNotFound)
		return
	}
	
	// Rate limiting per channel
	if !channel.allowRequest() {
		mSendRejected.Inc()
		http.Error(w, "rate limit exceeded", http.StatusTooManyRequests)
		return
	}
	
	// Update channel activity
	channel.updateActivity()
	
	// Forward sealed envelope to Guardian (no decryption at Ingress!)
	guardianURL := getGuardianURL()
	respEnvelope, err := forwardToGuardian(r.Context(), guardianURL, &envelope)
	if err != nil {
		http.Error(w, "relay failed", http.StatusBadGateway)
		return
	}
	
	// Update metrics
	channel.incrementRelayed()
	reg.totalRelayed++
	
	// Return sealed response to client
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(respEnvelope)
}

// allowRequest checks if the channel has tokens available (token bucket)
func (ch *channelState) allowRequest() bool {
	ch.mu.Lock()
	defer ch.mu.Unlock()
	
	now := time.Now()
	
	// Reset bucket if window expired
	if now.After(ch.rateBucket.resetTime) {
		ch.rateBucket.tokens = ch.rateLimit
		ch.rateBucket.resetTime = now.Add(ch.rateWindow)
	}
	
	// Check tokens
	if ch.rateBucket.tokens <= 0 {
		return false
	}
	
	ch.rateBucket.tokens--
	return true
}

// updateActivity updates last activity timestamp
func (ch *channelState) updateActivity() {
	ch.mu.Lock()
	defer ch.mu.Unlock()
	ch.lastActivity = time.Now()
}

// incrementRelayed increments relayed counters
func (ch *channelState) incrementRelayed() {
	ch.mu.Lock()
	defer ch.mu.Unlock()
	ch.requestCount++
	ch.bytesRelayed += 1024 // Approximate
}

// forwardToGuardian forwards the sealed envelope to Guardian service
func forwardToGuardian(ctx context.Context, guardianURL string, envelope *wch.Envelope) (*wch.Envelope, error) {
	// Marshal envelope
	body, err := json.Marshal(envelope)
	if err != nil {
		return nil, err
	}
	
	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", guardianURL+"/wch/execute", bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	
	req.Header.Set("Content-Type", "application/json")
	
	// Add admission header if configured
	if secret := envStr("ADMISSION_SECRET", ""); secret != "" {
		// Add HMAC signature for service-to-service auth
		sig := generateAdmissionSignature(secret, serviceName, body)
		req.Header.Set("X-ShieldX-Admission", sig)
	}
	
	// Execute request with timeout
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("guardian returned status %d", resp.StatusCode)
	}
	
	// Parse response envelope
	var respEnvelope wch.Envelope
	if err := json.NewDecoder(resp.Body).Decode(&respEnvelope); err != nil {
		return nil, err
	}
	
	return &respEnvelope, nil
}

// requestGuardianPubKey fetches Guardian's public key for channel setup
func requestGuardianPubKey(ctx context.Context) ([]byte, error) {
	guardianURL := getGuardianURL()
	
	req, err := http.NewRequestWithContext(ctx, "GET", guardianURL+"/wch/pubkey", nil)
	if err != nil {
		return nil, err
	}
	
	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("guardian pubkey request failed: %d", resp.StatusCode)
	}
	
	var result struct {
		PubKeyB64 string `json:"pubKey"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}
	
	// Decode base64
	pubKey, err := base64DecodeString(result.PubKeyB64)
	if err != nil {
		return nil, err
	}
	
	return pubKey, nil
}

// policyAllowWCH checks if WCH is allowed for given tenant/scope
func policyAllowWCH(tenant, scope string) bool {
	// Check base policy
	if !policy.IsAllowed(pol, tenant, scope) {
		return false
	}
	
	// Additional WCH-specific checks can be added here
	// For now, if basic policy allows, WCH is allowed
	return true
}

// getGuardianURL returns the Guardian service URL
func getGuardianURL() string {
	url := envStr("GUARDIAN_URL", "http://localhost:9090")
	return strings.TrimRight(url, "/")
}

// generateChannelID generates a cryptographically random channel ID
func generateChannelID() (string, error) {
	b := make([]byte, 16)
	if _, err := crand.Read(b); err != nil {
		return "", err
	}
	return hex.EncodeToString(b), nil
}

// generateAdmissionSignature generates HMAC-SHA256 signature for admission header
func generateAdmissionSignature(secret, serviceName string, body []byte) string {
	// Use guard package if available, otherwise implement HMAC
	// This is a simplified version
	h := sha256.New()
	h.Write([]byte(secret))
	h.Write([]byte(serviceName))
	h.Write(body)
	return hex.EncodeToString(h.Sum(nil))
}

// Utility functions
func base64EncodeBytes(b []byte) string {
	return base64.StdEncoding.EncodeToString(b)
}

func base64DecodeString(s string) ([]byte, error) {
	return base64.StdEncoding.DecodeString(s)
}

func envStr(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

func getClaimString(claims map[string]interface{}, key string) string {
	if v, ok := claims[key]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}
